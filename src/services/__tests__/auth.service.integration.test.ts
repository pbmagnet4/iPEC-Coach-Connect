/**
 * Authentication Service Integration Tests
 * 
 * Comprehensive integration testing for AuthService with real Supabase
 * database operations, API integration, and end-to-end data flows.
 * 
 * These tests validate:
 * - Real database CRUD operations
 * - Supabase authentication integration
 * - Data consistency and integrity
 * - Transaction handling and rollbacks
 * - Real-time subscription handling
 * - Error propagation from database layer
 * - Performance under load
 * - Concurrent operation handling
 */

import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from 'vitest';
import { createClient } from '@supabase/supabase-js';
import { AuthService } from '../auth.service';
import { AuthTestDataFactory, AuthTestHelpers, AUTH_TEST_CONSTANTS } from '../../test/auth-test-utils';
import type { Database } from '../../types/database';

// Test database configuration
const TEST_SUPABASE_URL = process.env.VITE_SUPABASE_URL || 'http://localhost:54321';
const TEST_SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_ANON_KEY || 'test-anon-key';

// Create test Supabase client
const testSupabase = createClient<Database>(TEST_SUPABASE_URL, TEST_SUPABASE_ANON_KEY);

describe('AuthService Integration Tests', () => {\n  let authService: any;\n  let testUsers: any[] = [];\n  let testData: any = {};\n\n  beforeAll(async () => {\n    // Ensure test database is available\n    try {\n      const { data, error } = await testSupabase\n        .from('profiles')\n        .select('count')\n        .limit(1);\n      \n      if (error && error.message.includes('relation \"profiles\" does not exist')) {\n        throw new Error('Test database not available. Please run database migrations.');\n      }\n    } catch (error) {\n      console.warn('⚠️  Integration tests require a running Supabase instance');\n      console.warn('   Run: supabase start');\n      throw error;\n    }\n  });\n\n  beforeEach(async () => {\n    // Create fresh AuthService instance for each test\n    authService = new AuthService();\n    testUsers = [];\n    testData = {};\n    \n    // Wait for initialization\n    await AuthTestHelpers.delay(100);\n  });\n\n  afterEach(async () => {\n    // Clean up test data\n    await cleanupTestData();\n  });\n\n  afterAll(async () => {\n    // Final cleanup\n    await cleanupTestData();\n  });\n\n  /**\n   * Cleanup function to remove test data\n   */\n  async function cleanupTestData() {\n    try {\n      // Sign out any authenticated users\n      await testSupabase.auth.signOut();\n      \n      // Delete test coaches\n      if (testUsers.length > 0) {\n        const userIds = testUsers.map(u => u.id);\n        await testSupabase.from('coaches').delete().in('id', userIds);\n        await testSupabase.from('profiles').delete().in('id', userIds);\n      }\n      \n      // Clean up auth users (this requires admin privileges in real Supabase)\n      // For local testing, users will be cleaned up automatically\n    } catch (error) {\n      console.warn('Cleanup error:', error);\n    }\n  }\n\n  /**\n   * Create test user and add to cleanup list\n   */\n  async function createTestUser(userData: any = {}) {\n    const signUpData = AuthTestDataFactory.createSignUpData(userData);\n    \n    const { data, error } = await testSupabase.auth.signUp({\n      email: signUpData.email,\n      password: signUpData.password,\n      options: {\n        data: {\n          full_name: signUpData.fullName,\n          role: signUpData.role,\n        }\n      }\n    });\n\n    if (error) throw error;\n    if (!data.user) throw new Error('User creation failed');\n\n    testUsers.push(data.user);\n    return { user: data.user, signUpData };\n  }\n\n  describe('User Registration Integration', () => {\n    it('should create user with profile in database', async () => {\n      const signUpData = AuthTestDataFactory.createSignUpData({\n        email: `integration.test.${Date.now()}@example.com`\n      });\n\n      const result = await authService.signUp(signUpData);\n\n      expect(result.error).toBeUndefined();\n      expect(result.data).toBeDefined();\n      expect(result.data.email).toBe(signUpData.email);\n\n      if (result.data) {\n        testUsers.push(result.data);\n\n        // Verify profile was created in database\n        const { data: profile, error: profileError } = await testSupabase\n          .from('profiles')\n          .select('*')\n          .eq('id', result.data.id)\n          .single();\n\n        expect(profileError).toBeNull();\n        expect(profile).toBeDefined();\n        expect(profile.full_name).toBe(signUpData.fullName);\n        expect(profile.phone).toBe(signUpData.phone);\n      }\n    });\n\n    it('should handle duplicate email registration', async () => {\n      const signUpData = AuthTestDataFactory.createSignUpData({\n        email: `duplicate.test.${Date.now()}@example.com`\n      });\n\n      // First registration should succeed\n      const firstResult = await authService.signUp(signUpData);\n      expect(firstResult.error).toBeUndefined();\n      \n      if (firstResult.data) {\n        testUsers.push(firstResult.data);\n      }\n\n      // Second registration with same email should fail\n      const secondResult = await authService.signUp(signUpData);\n      expect(secondResult.error).toBeDefined();\n      expect(secondResult.error?.message).toMatch(/already registered|already exists/i);\n    });\n\n    it('should validate email format in database', async () => {\n      const invalidEmailData = AuthTestDataFactory.createSignUpData({\n        email: 'invalid-email-format'\n      });\n\n      const result = await authService.signUp(invalidEmailData);\n\n      expect(result.error).toBeDefined();\n      expect(result.error?.message).toMatch(/email|format|invalid/i);\n    });\n  });\n\n  describe('Authentication Flow Integration', () => {\n    it('should authenticate and load user data from database', async () => {\n      // Create test user\n      const { user, signUpData } = await createTestUser();\n\n      // Attempt sign in\n      const signInResult = await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      expect(signInResult.error).toBeUndefined();\n      expect(signInResult.data).toBeDefined();\n\n      // Wait for user data to load\n      const finalState = await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && !state.isLoading,\n        AUTH_TEST_CONSTANTS.TIMEOUTS.NORMAL\n      );\n\n      expect(finalState.user?.id).toBe(user.id);\n      expect(finalState.profile).toBeDefined();\n      expect(finalState.isAuthenticated).toBe(true);\n    });\n\n    it('should reject invalid credentials', async () => {\n      const { signUpData } = await createTestUser();\n\n      const invalidSignIn = await authService.signIn({\n        email: signUpData.email,\n        password: 'wrong-password'\n      });\n\n      expect(invalidSignIn.error).toBeDefined();\n      expect(invalidSignIn.error?.message).toMatch(/invalid|incorrect|wrong/i);\n    });\n\n    it('should handle non-existent user sign in', async () => {\n      const nonExistentSignIn = await authService.signIn({\n        email: 'nonexistent@example.com',\n        password: 'password123'\n      });\n\n      expect(nonExistentSignIn.error).toBeDefined();\n      expect(nonExistentSignIn.error?.message).toMatch(/invalid|not found|user/i);\n    });\n  });\n\n  describe('Profile Management Integration', () => {\n    it('should update profile in database', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      // Sign in to load profile\n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      // Wait for authentication\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      const updateData = {\n        full_name: 'Updated Test User',\n        bio: 'Updated bio for integration testing',\n        location: 'Updated Location'\n      };\n\n      const updateResult = await authService.updateProfile(updateData);\n\n      expect(updateResult.error).toBeUndefined();\n      expect(updateResult.data).toBeDefined();\n      expect(updateResult.data?.full_name).toBe(updateData.full_name);\n\n      // Verify update in database\n      const { data: dbProfile, error: dbError } = await testSupabase\n        .from('profiles')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      expect(dbError).toBeNull();\n      expect(dbProfile.full_name).toBe(updateData.full_name);\n      expect(dbProfile.bio).toBe(updateData.bio);\n    });\n\n    it('should handle concurrent profile updates', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      // Perform concurrent updates\n      const updates = [\n        authService.updateProfile({ full_name: 'Update 1' }),\n        authService.updateProfile({ bio: 'Update 2' }),\n        authService.updateProfile({ location: 'Update 3' })\n      ];\n\n      const results = await Promise.all(updates);\n\n      // All updates should succeed (last one wins)\n      results.forEach(result => {\n        expect(result.error).toBeUndefined();\n      });\n    });\n  });\n\n  describe('Coach Application Integration', () => {\n    it('should create coach record in database', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      const coachData = AuthTestDataFactory.createCoachApplicationData();\n      const result = await authService.applyAsCoach(coachData);\n\n      expect(result.error).toBeUndefined();\n      expect(result.data).toBeDefined();\n      expect(result.data?.ipec_certification_number).toBe(coachData.ipecCertificationNumber);\n\n      // Verify coach record in database\n      const { data: dbCoach, error: dbError } = await testSupabase\n        .from('coaches')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      expect(dbError).toBeNull();\n      expect(dbCoach.certification_level).toBe(coachData.certificationLevel);\n      expect(dbCoach.is_active).toBe(false); // Should require verification\n    });\n\n    it('should prevent duplicate coach applications', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      const coachData = AuthTestDataFactory.createCoachApplicationData();\n      \n      // First application should succeed\n      const firstResult = await authService.applyAsCoach(coachData);\n      expect(firstResult.error).toBeUndefined();\n\n      // Second application should fail\n      const secondResult = await authService.applyAsCoach(coachData);\n      expect(secondResult.error).toBeDefined();\n    });\n  });\n\n  describe('Permission System Integration', () => {\n    it('should enforce role-based permissions from database', async () => {\n      const { user, signUpData } = await createTestUser({ role: 'client' });\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      const state = await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.role === 'client'\n      );\n\n      // Client permissions\n      expect(authService.hasPermission('canCreateSessions')).toBe(false);\n      expect(authService.hasPermission('canAccessAdminPanel')).toBe(false);\n      expect(authService.hasPermission('canModerateContent')).toBe(false);\n    });\n\n    it('should update permissions when user becomes coach', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      // Initially client permissions\n      expect(authService.hasPermission('canCreateSessions')).toBe(false);\n      expect(authService.hasPermission('canManageCoachProfile')).toBe(false);\n\n      // Apply as coach\n      const coachData = AuthTestDataFactory.createCoachApplicationData();\n      await authService.applyAsCoach(coachData);\n\n      // Should now have coach permissions (but inactive)\n      expect(authService.hasPermission('canManageCoachProfile')).toBe(true);\n      expect(authService.hasPermission('canCreateSessions')).toBe(false); // Still inactive\n    });\n  });\n\n  describe('Real-time Subscription Integration', () => {\n    it('should handle auth state changes from external login', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      // Set up state change listener\n      let stateChanges: any[] = [];\n      const unsubscribe = authService.onStateChange((state: any) => {\n        stateChanges.push({ ...state });\n      });\n\n      // External sign in (simulates login from another tab/device)\n      await testSupabase.auth.signInWithPassword({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      // Wait for state changes to propagate\n      await AuthTestHelpers.delay(500);\n\n      // Should have received sign-in state change\n      const authenticatedStates = stateChanges.filter(s => s.isAuthenticated);\n      expect(authenticatedStates.length).toBeGreaterThan(0);\n\n      unsubscribe();\n    });\n  });\n\n  describe('Error Handling Integration', () => {\n    it('should handle database connection errors gracefully', async () => {\n      // This test would require a way to simulate database downtime\n      // For now, we'll test with malformed queries\n      \n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated\n      );\n\n      // Test update with invalid data type (should be caught by database)\n      const result = await authService.updateProfile({\n        phone: null as any // This should be handled gracefully\n      });\n\n      // Should either succeed with null or handle gracefully\n      expect(result).toBeDefined();\n    });\n\n    it('should handle session expiry during operations', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated\n      );\n\n      // Force sign out (simulates session expiry)\n      await testSupabase.auth.signOut();\n      \n      // Wait for sign out to propagate\n      await AuthTestHelpers.delay(200);\n\n      // Attempt operation after session expiry\n      const result = await authService.updateProfile({\n        full_name: 'Should Fail'\n      });\n\n      expect(result.error).toBeDefined();\n      expect(result.error?.message).toMatch(/not authenticated|session|expired/i);\n    });\n  });\n\n  describe('Performance Integration', () => {\n    it('should handle rapid successive operations', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      const startTime = Date.now();\n      \n      // Perform multiple rapid updates\n      const operations = [];\n      for (let i = 0; i < 10; i++) {\n        operations.push(\n          authService.updateProfile({ bio: `Update ${i}` })\n        );\n      }\n\n      const results = await Promise.all(operations);\n      const endTime = Date.now();\n\n      // All operations should complete within reasonable time\n      expect(endTime - startTime).toBeLessThan(5000);\n      \n      // Most operations should succeed (some may conflict)\n      const successCount = results.filter(r => !r.error).length;\n      expect(successCount).toBeGreaterThan(0);\n    });\n\n    it('should maintain state consistency under concurrent access', async () => {\n      const users = [];\n      \n      // Create multiple test users\n      for (let i = 0; i < 3; i++) {\n        users.push(await createTestUser({\n          email: `concurrent.test.${i}.${Date.now()}@example.com`\n        }));\n      }\n\n      // Sign in all users concurrently\n      const signInPromises = users.map(({ signUpData }) => \n        authService.signIn({\n          email: signUpData.email,\n          password: signUpData.password\n        })\n      );\n\n      const signInResults = await Promise.all(signInPromises);\n      \n      // All sign-ins should succeed\n      signInResults.forEach(result => {\n        expect(result.error).toBeUndefined();\n      });\n    });\n  });\n\n  describe('Data Consistency Integration', () => {\n    it('should maintain referential integrity between auth and profile', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      // Verify auth user exists\n      const { data: authUser, error: authError } = await testSupabase.auth.getUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      // Verify profile references correct auth user\n      const { data: profile } = await testSupabase\n        .from('profiles')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      expect(profile.id).toBe(user.id);\n    });\n\n    it('should cascade coach deletion when profile is deleted', async () => {\n      const { user, signUpData } = await createTestUser();\n      \n      await authService.signIn({\n        email: signUpData.email,\n        password: signUpData.password\n      });\n\n      await AuthTestHelpers.waitForAuthState(\n        authService,\n        state => state.isAuthenticated && state.profile !== null\n      );\n\n      // Create coach record\n      const coachData = AuthTestDataFactory.createCoachApplicationData();\n      await authService.applyAsCoach(coachData);\n\n      // Verify coach exists\n      const { data: coach } = await testSupabase\n        .from('coaches')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      expect(coach).toBeDefined();\n\n      // Delete profile (should cascade to coach)\n      await testSupabase\n        .from('profiles')\n        .delete()\n        .eq('id', user.id);\n\n      // Verify coach is also deleted\n      const { data: deletedCoach } = await testSupabase\n        .from('coaches')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      expect(deletedCoach).toBeNull();\n    });\n  });\n});