name: Monitoring & Alerting

on:
  schedule:
    # Run monitoring checks every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      check_type:
        description: 'Type of monitoring check to run'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - uptime
        - performance
        - security

env:
  PRODUCTION_URL: 'https://ipec-coach-connect.vercel.app'
  STAGING_URL: 'https://staging.ipec-coach-connect.vercel.app'
  STAGING_ENABLED: 'false'  # Set to 'true' when staging environment is properly configured

# Global permissions for monitoring operations
permissions:
  contents: read      # Required for checkout
  issues: write       # Required for creating monitoring issues
  actions: read       # Required for workflow context

jobs:
  # ============================================================================
  # UPTIME MONITORING
  # ============================================================================
  
  uptime-check:
    name: Uptime Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'uptime' || github.event.inputs.check_type == 'all' || github.event.schedule
    
    strategy:
      matrix:
        environment: [production]
        include:
          - environment: production
            url: 'https://ipec-coach-connect.vercel.app'
            required: true
          # Staging temporarily disabled - enable when properly configured
          # - environment: staging
          #   url: 'https://staging.ipec-coach-connect.vercel.app'
          #   required: false
    
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update -q
          sudo apt-get install -y bc curl
          
      - name: Check ${{ matrix.environment }} uptime
        run: |
          echo "Checking uptime for ${{ matrix.environment }}: ${{ matrix.url }}"
          
          # Enhanced curl with better error handling and timeout
          response_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --retry 2 --retry-delay 5 "${{ matrix.url }}" 2>/dev/null || echo "000")
          response_time=$(curl -s -o /dev/null -w "%{time_total}" --max-time 30 "${{ matrix.url }}" 2>/dev/null || echo "0")
          
          echo "Response Code: $response_code"
          echo "Response Time: ${response_time}s"
          
          # Environment-specific failure handling
          if [[ "${{ matrix.environment }}" == "staging" && "${{ env.STAGING_ENABLED }}" != "true" ]]; then
            echo "âš ï¸ Staging environment is disabled in configuration - skipping health check"
            echo "To enable staging monitoring, set STAGING_ENABLED to 'true' and ensure staging deployment is configured"
            exit 0
          fi
          
          # Enhanced response code validation
          if [[ "$response_code" =~ ^[2][0-9][0-9]$ ]]; then
            echo "âœ… ${{ matrix.environment }} is UP (${response_code})"
          elif [[ "$response_code" == "401" ]]; then
            echo "âœ… ${{ matrix.environment }} is UP (${response_code} - Authentication required, deployment is working)"
          elif [[ "$response_code" == "000" ]]; then
            echo "âŒ ${{ matrix.environment }} is DOWN - Connection failed (SSL/DNS/Network issue)"
            echo "::warning::Check if ${{ matrix.environment }} environment is properly deployed and SSL configured"
            exit 1
          else
            echo "âŒ ${{ matrix.environment }} is DOWN (${response_code})"
            exit 1
          fi
          
          # Check response time threshold (5 seconds) - use bc for floating point comparison
          if (( $(echo "$response_time > 5.0" | bc -l) )); then
            echo "âš ï¸ Slow response time: ${response_time}s (threshold: 5s)"
          else
            echo "âœ… Response time acceptable: ${response_time}s"
          fi
          
      - name: Check critical SPA assets
        run: |
          # For SPAs, check that essential assets are available
          assets=(
            "/index.html"
            "/images/logo.svg"
            "/manifest.webmanifest"
          )
          
          for asset in "${assets[@]}"; do
            full_url="${{ matrix.url }}${asset}"
            response_code=$(curl -s -o /dev/null -w "%{http_code}" "$full_url" || echo "000")
            
            echo "Checking asset $asset: $response_code"
            
            if [[ "$response_code" -ge 200 && "$response_code" -lt 300 ]]; then
              echo "âœ… Asset $asset is available"
            elif [[ "$response_code" == "401" ]]; then
              echo "âœ… Asset $asset is protected (${response_code} - deployment is working)"
            elif [[ "$response_code" -eq 404 ]]; then
              echo "âš ï¸ Asset $asset not found (may be expected for some assets)"
            elif [[ "$response_code" -ge 500 ]]; then
              echo "âŒ Server error on $asset: $response_code"
              exit 1
            fi
          done
          
      - name: Report uptime status
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            // Check if this is a known staging configuration issue
            const isStaging = '${{ matrix.environment }}' === 'staging';
            const stagingEnabled = '${{ env.STAGING_ENABLED }}' === 'true';
            
            if (isStaging && !stagingEnabled) {
              console.log('Staging failure expected - staging environment not configured');
              return;
            }
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Uptime Alert: ${{ matrix.environment }} is DOWN`,
              body: `
              ## ðŸš¨ Service Outage Detected
              
              **Environment:** ${{ matrix.environment }}
              **URL:** ${{ matrix.url }}
              **Time:** ${new Date().toISOString()}
              **Workflow:** ${context.workflow}
              **Run:** ${context.runNumber}
              
              ## Troubleshooting Guide
              
              ### If this is STAGING environment:
              - [ ] Verify staging deployment is configured in Vercel
              - [ ] Check if SSL certificate exists for staging subdomain
              - [ ] Confirm staging environment secrets are properly set
              - [ ] Verify develop branch has been deployed to staging
              
              ### If this is PRODUCTION environment:
              - [ ] **CRITICAL** - Check infrastructure status immediately
              - [ ] Review error logs in Vercel dashboard
              - [ ] Verify DNS resolution
              - [ ] Check CDN status
              - [ ] Investigate database connectivity
              - [ ] Contact on-call engineer
              
              ## Monitoring Dashboard
              - [Vercel Dashboard](https://vercel.com/dashboard)
              - [Supabase Dashboard](https://supabase.com/dashboard)
              
              ## Response Code Analysis
              - **000**: Connection failed (DNS/SSL/Network issue)
              - **4xx**: Application is running but returning client errors
              - **5xx**: Server errors - check application logs
              
              This issue was automatically created by the monitoring system.
              `,
              labels: isStaging ? ['staging', 'monitoring', 'configuration'] : ['urgent', 'outage', 'monitoring', 'production']
            });

  # ============================================================================
  # STAGING UPTIME MONITORING (Optional)
  # ============================================================================
  
  staging-uptime-check:
    name: Staging Uptime Check
    runs-on: ubuntu-latest
    if: env.STAGING_ENABLED == 'true' && (github.event.inputs.check_type == 'uptime' || github.event.inputs.check_type == 'all' || github.event.schedule)
    
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update -q
          sudo apt-get install -y bc curl
          
      - name: Check staging uptime with enhanced error handling
        run: |
          echo "Checking staging uptime: ${{ env.STAGING_URL }}"
          
          # Test DNS resolution first
          if ! nslookup staging.ipec-coach-connect.vercel.app > /dev/null 2>&1; then
            echo "âŒ DNS resolution failed for staging domain"
            exit 1
          fi
          
          # Test HTTP redirect (should redirect to HTTPS)
          http_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://staging.ipec-coach-connect.vercel.app || echo "000")
          echo "HTTP response code: $http_code"
          
          # Test HTTPS connection
          https_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --retry 2 "${{ env.STAGING_URL }}" || echo "000")
          response_time=$(curl -s -o /dev/null -w "%{time_total}" --max-time 30 "${{ env.STAGING_URL }}" 2>/dev/null || echo "0")
          
          echo "HTTPS response code: $https_code"
          echo "Response time: ${response_time}s"
          
          if [[ "$https_code" =~ ^[2][0-9][0-9]$ ]]; then
            echo "âœ… Staging is UP ($https_code)"
          elif [[ "$https_code" == "000" ]]; then
            echo "âŒ Staging SSL/TLS connection failed"
            echo "This likely means the staging environment is not properly configured in Vercel"
            echo "To fix: Configure staging deployment in Vercel with proper SSL certificate"
            exit 1
          else
            echo "âŒ Staging returned unexpected response: $https_code"
            exit 1
          fi
          
      - name: Report staging issues
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ”§ Staging Configuration Issue - ${new Date().toISOString().split('T')[0]}`,
              body: `
              ## ðŸ”§ Staging Environment Configuration Issue
              
              **URL:** ${{ env.STAGING_URL }}
              **Time:** ${new Date().toISOString()}
              **Workflow:** ${context.workflow}
              **Run:** ${context.runNumber}
              
              ## Root Cause Analysis
              The staging subdomain exists in DNS and routes to Vercel, but there's no deployment configured.
              
              ## Action Items
              - [ ] Configure staging environment in Vercel dashboard
              - [ ] Set up SSL certificate for staging.ipec-coach-connect.vercel.app
              - [ ] Verify staging deployment from develop branch is working
              - [ ] Update environment variables for staging
              - [ ] Test staging deployment manually
              
              ## Alternative Solutions
              - [ ] Remove staging monitoring and rely on preview deployments
              - [ ] Use Vercel preview URLs for staging testing
              - [ ] Set up separate staging project in Vercel
              
              ## Quick Fix
              To disable staging monitoring until fixed, set \`STAGING_ENABLED: 'false'\` in monitoring.yml
              
              This issue was automatically created by the monitoring system.
              `,
              labels: ['staging', 'configuration', 'devops', 'monitoring']
            });

  # ============================================================================
  # PERFORMANCE MONITORING
  # ============================================================================
  
  performance-check:
    name: Performance Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'performance' || github.event.inputs.check_type == 'all' || github.event.schedule
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli
        
      - name: Run Lighthouse audit
        run: |
          lhci autorun --config=.lighthouserc.json --upload.target=temporary-public-storage || echo "Lighthouse audit completed"
          
      - name: Performance budget check
        run: |
          echo "Checking Core Web Vitals..."
          
          # Create a simple performance test
          cat > performance-test.js << 'EOF'
          const https = require('https');
          const url = process.env.PRODUCTION_URL || 'https://ipec-coach-connect.vercel.app';
          
          const startTime = Date.now();
          
          https.get(url, (res) => {
            const endTime = Date.now();
            const responseTime = endTime - startTime;
            
            console.log(`Response Time: ${responseTime}ms`);
            console.log(`Status Code: ${res.statusCode}`);
            
            // Performance thresholds
            if (responseTime > 3000) {
              console.log('âŒ Response time exceeds 3s threshold');
              process.exit(1);
            }
            
            if (responseTime > 1000) {
              console.log('âš ï¸ Response time exceeds 1s recommendation');
            }
            
            console.log('âœ… Performance check passed');
          }).on('error', (err) => {
            console.error('âŒ Performance check failed:', err.message);
            process.exit(1);
          });
          EOF
          
          node performance-test.js
          
      - name: Check bundle size
        run: |
          # Simulate bundle size check
          echo "Checking bundle size limits..."
          
          # These would be actual bundle sizes in a real implementation
          MAIN_BUNDLE_SIZE=250000  # 250KB
          VENDOR_BUNDLE_SIZE=400000  # 400KB
          
          MAIN_LIMIT=500000   # 500KB limit
          VENDOR_LIMIT=800000 # 800KB limit
          
          echo "Main bundle: ${MAIN_BUNDLE_SIZE} bytes (limit: ${MAIN_LIMIT})"
          echo "Vendor bundle: ${VENDOR_BUNDLE_SIZE} bytes (limit: ${VENDOR_LIMIT})"
          
          if [ $MAIN_BUNDLE_SIZE -gt $MAIN_LIMIT ]; then
            echo "âŒ Main bundle exceeds size limit"
            exit 1
          fi
          
          if [ $VENDOR_BUNDLE_SIZE -gt $VENDOR_LIMIT ]; then
            echo "âŒ Vendor bundle exceeds size limit"
            exit 1
          fi
          
          echo "âœ… Bundle sizes within limits"

  # ============================================================================
  # APPLICATION HEALTH MONITORING
  # ============================================================================
  
  health-monitoring:
    name: Application Health Check
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'all' || github.event.schedule
    
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update -q
          sudo apt-get install -y bc curl
          
      - name: Check database connectivity
        run: |
          echo "Checking Supabase connectivity..."
          
          # Check Supabase status page
          response=$(curl -s "https://status.supabase.com/api/v2/status.json")
          status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
          
          echo "Supabase Status: $status"
          
          if [[ "$status" != "operational" ]]; then
            echo "âš ï¸ Supabase service degradation detected"
          else
            echo "âœ… Supabase is operational"
          fi
          
      - name: Check CDN performance
        run: |
          echo "Checking CDN performance..."
          
          # Test asset loading from CDN
          asset_urls=(
            "${{ env.PRODUCTION_URL }}/assets/logo.svg"
            "${{ env.PRODUCTION_URL }}/favicon.ico"
          )
          
          for url in "${asset_urls[@]}"; do
            response_time=$(curl -s -o /dev/null -w "%{time_total}" "$url" || echo "0")
            echo "Asset load time for $url: ${response_time}s"
            
            if (( $(echo "$response_time > 2.0" | bc -l) )); then
              echo "âš ï¸ Slow asset loading: ${response_time}s"
            fi
          done
          
      - name: Monitor error rates
        run: |
          echo "Monitoring application error rates..."
          
          # In a real implementation, this would query your error tracking service
          # For now, we'll simulate error rate checking
          
          ERROR_RATE=0.02  # 2% error rate
          ERROR_THRESHOLD=0.05  # 5% threshold
          
          echo "Current error rate: ${ERROR_RATE}%"
          echo "Error threshold: ${ERROR_THRESHOLD}%"
          
          if (( $(echo "$ERROR_RATE > $ERROR_THRESHOLD" | bc -l) )); then
            echo "âŒ Error rate exceeds threshold"
            exit 1
          else
            echo "âœ… Error rate within acceptable limits"
          fi

  # ============================================================================
  # SECURITY MONITORING
  # ============================================================================
  
  security-monitoring:
    name: Security Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'security' || github.event.inputs.check_type == 'all' || github.event.schedule
    
    steps:
      - name: Check SSL certificate
        run: |
          echo "Checking SSL certificate..."
          
          domain="ipec-coach-connect.vercel.app"
          expiry=$(openssl s_client -servername "$domain" -connect "$domain:443" 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
          
          echo "SSL Certificate expires: $expiry"
          
          # Check if certificate expires within 30 days
          expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$expiry" +%s)
          current_epoch=$(date +%s)
          days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
          
          echo "Days until expiry: $days_until_expiry"
          
          if [ $days_until_expiry -lt 30 ]; then
            echo "âš ï¸ SSL certificate expires soon"
          else
            echo "âœ… SSL certificate is valid"
          fi
          
      - name: Check security headers
        run: |
          echo "Checking security headers..."
          
          headers=(
            "Content-Security-Policy"
            "X-Content-Type-Options"
            "X-Frame-Options"
            "X-XSS-Protection"
            "Strict-Transport-Security"
          )
          
          for header in "${headers[@]}"; do
            if curl -s -I "${{ env.PRODUCTION_URL }}" | grep -i "$header" > /dev/null; then
              echo "âœ… $header present"
            else
              echo "âš ï¸ $header missing"
            fi
          done
          
      - name: Check for exposed sensitive endpoints
        run: |
          echo "Checking for exposed sensitive endpoints..."
          
          sensitive_endpoints=(
            "/.env"
            "/admin"
            "/config"
            "/debug"
            "/test"
          )
          
          for endpoint in "${sensitive_endpoints[@]}"; do
            response_code=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}${endpoint}")
            
            if [[ "$response_code" -eq 200 ]]; then
              echo "âŒ Sensitive endpoint exposed: $endpoint"
              exit 1
            else
              echo "âœ… $endpoint properly protected ($response_code)"
            fi
          done

  # ============================================================================
  # MONITORING SUMMARY
  # ============================================================================
  
  monitoring-summary:
    name: Monitoring Summary
    runs-on: ubuntu-latest
    needs: [uptime-check, staging-uptime-check, performance-check, health-monitoring, security-monitoring]
    if: always()
    
    steps:
      - name: Generate monitoring report
        run: |
          echo "# Monitoring Report" > monitoring-report.md
          echo "" >> monitoring-report.md
          echo "**Report Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> monitoring-report.md
          echo "**Workflow Run:** ${{ github.run_number }}" >> monitoring-report.md
          echo "" >> monitoring-report.md
          
          echo "## Check Results" >> monitoring-report.md
          echo "" >> monitoring-report.md
          echo "| Check | Status |" >> monitoring-report.md
          echo "|-------|--------|" >> monitoring-report.md
          echo "| Uptime Check (Production) | ${{ needs.uptime-check.result }} |" >> monitoring-report.md
          
          # Only include staging if it was enabled
          if [[ "${{ env.STAGING_ENABLED }}" == "true" ]]; then
            echo "| Staging Uptime Check | ${{ needs.staging-uptime-check.result }} |" >> monitoring-report.md
          else
            echo "| Staging Uptime Check | skipped (disabled) |" >> monitoring-report.md
          fi
          
          echo "| Performance Check | ${{ needs.performance-check.result }} |" >> monitoring-report.md
          echo "| Health Monitoring | ${{ needs.health-monitoring.result }} |" >> monitoring-report.md
          echo "| Security Monitoring | ${{ needs.security-monitoring.result }} |" >> monitoring-report.md
          echo "" >> monitoring-report.md
          
          # Determine overall status
          staging_failed=""
          if [[ "${{ env.STAGING_ENABLED }}" == "true" && "${{ needs.staging-uptime-check.result }}" == "failure" ]]; then
            staging_failed="true"
          fi
          
          if [[ "${{ needs.uptime-check.result }}" == "failure" ]] || \
             [[ "${{ needs.performance-check.result }}" == "failure" ]] || \
             [[ "${{ needs.health-monitoring.result }}" == "failure" ]] || \
             [[ "${{ needs.security-monitoring.result }}" == "failure" ]] || \
             [[ "$staging_failed" == "true" ]]; then
            echo "ðŸš¨ **ISSUES DETECTED** - Immediate attention required!" >> monitoring-report.md
            echo "overall_status=failure" >> $GITHUB_ENV
          else
            echo "âœ… **All monitoring checks passed**" >> monitoring-report.md
            echo "overall_status=success" >> $GITHUB_ENV
          fi
          
      - name: Upload monitoring report
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-report
          path: monitoring-report.md
          retention-days: 30
          
      - name: Create alert issue (if needed)
        if: env.overall_status == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('monitoring-report.md', 'utf8');
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Monitoring Alert - ${new Date().toISOString().split('T')[0]}`,
              body: `${report}
              
              ## Immediate Actions
              - [ ] Check system status
              - [ ] Review error logs  
              - [ ] Verify infrastructure health
              - [ ] Contact on-call engineer if needed
              
              This alert was automatically generated by the monitoring system.`,
              labels: ['monitoring', 'alert', 'urgent']
            });