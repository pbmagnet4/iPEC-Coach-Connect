/**
 * Authentication Security Tests
 * 
 * Comprehensive security testing for authentication system covering:
 * - Input validation and sanitization
 * - Session management security
 * - Permission boundary validation
 * - CSRF and XSS protection
 * - Rate limiting and brute force protection
 * - Secure headers and cookies
 * - Role escalation prevention
 * - Data exposure prevention
 */

import { test, expect, Page } from '@playwright/test';\n\ntest.describe('Authentication Security Tests', () => {\n  test.describe('Input Validation and Sanitization', () => {\n    test('should sanitize XSS attempts in login fields', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const xssPayloads = [\n        '<script>alert(\"XSS\")</script>',\n        'javascript:alert(\"XSS\")',\n        '<img src=x onerror=alert(\"XSS\")>',\n        '\\\"onmouseover=alert(\"XSS\")//'\n      ];\n      \n      for (const payload of xssPayloads) {\n        await page.fill('[data-testid=\"login-email\"]', payload);\n        await page.fill('[data-testid=\"login-password\"]', payload);\n        \n        // Submit form\n        await page.click('[data-testid=\"login-submit\"]');\n        \n        // Should not execute any scripts\n        const alertHandled = await page.evaluate(() => {\n          return new Promise(resolve => {\n            const originalAlert = window.alert;\n            window.alert = () => {\n              resolve(true);\n              window.alert = originalAlert;\n            };\n            setTimeout(() => resolve(false), 100);\n          });\n        });\n        \n        expect(alertHandled).toBe(false);\n        \n        // Clear fields for next test\n        await page.fill('[data-testid=\"login-email\"]', '');\n        await page.fill('[data-testid=\"login-password\"]', '');\n      }\n    });\n\n    test('should prevent SQL injection attempts', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const sqlPayloads = [\n        \"'; DROP TABLE users; --\",\n        \"' OR '1'='1\",\n        \"admin'--\",\n        \"' UNION SELECT * FROM users --\",\n        \"'; INSERT INTO users VALUES ('hacker', 'password'); --\"\n      ];\n      \n      for (const payload of sqlPayloads) {\n        await page.fill('[data-testid=\"login-email\"]', payload);\n        await page.fill('[data-testid=\"login-password\"]', 'password123');\n        \n        await page.click('[data-testid=\"login-submit\"]');\n        \n        // Should show invalid credentials, not SQL error\n        const errorMessage = await page.locator('[data-testid=\"error-message\"]').textContent();\n        expect(errorMessage).toMatch(/invalid|incorrect|wrong/i);\n        expect(errorMessage).not.toMatch(/sql|syntax|database/i);\n        \n        // Should not be authenticated\n        await expect(page.locator('[data-testid=\"user-menu\"]')).not.toBeVisible();\n        \n        await page.fill('[data-testid=\"login-email\"]', '');\n        await page.fill('[data-testid=\"login-password\"]', '');\n      }\n    });\n\n    test('should validate and reject malformed email formats', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      const invalidEmails = [\n        'invalid-email',\n        '@domain.com',\n        'user@',\n        'user..double.dot@domain.com',\n        'user@domain',\n        'user name@domain.com', // space in email\n        'user@domain..com', // double dot in domain\n        ''\n      ];\n      \n      for (const email of invalidEmails) {\n        await page.fill('[data-testid=\"registration-email\"]', email);\n        await page.fill('[data-testid=\"registration-password\"]', 'ValidPassword123!');\n        await page.fill('[data-testid=\"registration-full-name\"]', 'Test User');\n        \n        // Should show validation error or disable submit\n        const submitButton = page.locator('[data-testid=\"register-submit\"]');\n        const isDisabled = await submitButton.isDisabled();\n        \n        if (!isDisabled) {\n          await submitButton.click();\n          await expect(page.locator('[data-testid=\"email-error\"]'))\n            .toContainText(/invalid|format|email/i);\n        }\n        \n        await page.fill('[data-testid=\"registration-email\"]', '');\n      }\n    });\n\n    test('should enforce strong password requirements', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      const weakPasswords = [\n        '123', // Too short\n        'password', // No numbers/symbols\n        'PASSWORD', // No lowercase\n        '12345678', // No letters\n        'Pass123', // Too short\n        'password123', // No symbols\n        'PASSWORD123!' // No lowercase\n      ];\n      \n      for (const password of weakPasswords) {\n        await page.fill('[data-testid=\"registration-email\"]', 'test@example.com');\n        await page.fill('[data-testid=\"registration-password\"]', password);\n        \n        // Should show password strength indicator\n        await expect(page.locator('[data-testid=\"password-strength\"]')).toBeVisible();\n        \n        // Submit should be disabled for weak passwords\n        const submitButton = page.locator('[data-testid=\"register-submit\"]');\n        await expect(submitButton).toBeDisabled();\n        \n        await page.fill('[data-testid=\"registration-password\"]', '');\n      }\n    });\n  });\n\n  test.describe('Session Management Security', () => {\n    test('should use secure session cookies', async ({ page }) => {\n      // Login to get session cookie\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Wait for potential redirect\n      await page.waitForTimeout(1000);\n      \n      // Check cookie security attributes\n      const cookies = await page.context().cookies();\n      const sessionCookies = cookies.filter(cookie => \n        cookie.name.includes('session') || \n        cookie.name.includes('auth') ||\n        cookie.name.includes('supabase')\n      );\n      \n      for (const cookie of sessionCookies) {\n        // Should be HTTP-only (not accessible via JavaScript)\n        expect(cookie.httpOnly).toBe(true);\n        \n        // Should be secure in production\n        if (process.env.NODE_ENV === 'production') {\n          expect(cookie.secure).toBe(true);\n        }\n        \n        // Should have SameSite protection\n        expect(['Strict', 'Lax']).toContain(cookie.sameSite);\n      }\n    });\n\n    test('should invalidate session on logout', async ({ page }) => {\n      // Login first\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Assume successful login and navigate to dashboard\n      await page.waitForURL('**/dashboard**', { timeout: 5000 }).catch(() => {});\n      \n      // Get session before logout\n      const sessionBefore = await page.evaluate(() => {\n        return {\n          localStorage: { ...localStorage },\n          sessionStorage: { ...sessionStorage }\n        };\n      });\n      \n      // Logout\n      await page.click('[data-testid=\"user-menu\"]');\n      await page.click('[data-testid=\"logout-button\"]');\n      \n      // Verify session is cleared\n      const sessionAfter = await page.evaluate(() => {\n        return {\n          localStorage: { ...localStorage },\n          sessionStorage: { ...sessionStorage }\n        };\n      });\n      \n      // Should have cleared auth-related storage\n      expect(Object.keys(sessionAfter.localStorage)).not.toContain('supabase.auth.token');\n      expect(Object.keys(sessionAfter.sessionStorage)).not.toContain('supabase.auth.token');\n      \n      // Should not be able to access protected routes\n      await page.goto('/dashboard');\n      await page.waitForURL('**/auth/login');\n    });\n\n    test('should handle session timeout appropriately', async ({ page }) => {\n      // This test simulates session expiry\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Simulate session expiry by clearing auth tokens\n      await page.evaluate(() => {\n        // Clear all auth-related storage\n        Object.keys(localStorage).forEach(key => {\n          if (key.includes('auth') || key.includes('supabase')) {\n            localStorage.removeItem(key);\n          }\n        });\n        Object.keys(sessionStorage).forEach(key => {\n          if (key.includes('auth') || key.includes('supabase')) {\n            sessionStorage.removeItem(key);\n          }\n        });\n      });\n      \n      // Try to access protected route\n      await page.goto('/dashboard/profile');\n      \n      // Should redirect to login\n      await page.waitForURL('**/auth/login');\n      \n      // Should show session expired message\n      await expect(page.locator('[data-testid=\"session-expired\"]'))\n        .toBeVisible({ timeout: 2000 })\n        .catch(() => {\n          // Session expiry message might not be implemented yet\n          console.warn('Session expiry message not found');\n        });\n    });\n  });\n\n  test.describe('Permission Boundary Validation', () => {\n    test('should prevent access to admin routes for non-admin users', async ({ page }) => {\n      // Login as regular user\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'regular.user@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Try to access admin routes\n      const adminRoutes = [\n        '/admin',\n        '/admin/users',\n        '/admin/coaches',\n        '/admin/analytics',\n        '/admin/settings'\n      ];\n      \n      for (const route of adminRoutes) {\n        await page.goto(route);\n        \n        // Should either redirect or show access denied\n        const currentUrl = page.url();\n        const hasAccessDenied = await page.locator('[data-testid=\"access-denied\"]')\n          .isVisible({ timeout: 2000 })\n          .catch(() => false);\n        \n        const isRedirected = !currentUrl.includes(route);\n        \n        expect(hasAccessDenied || isRedirected).toBe(true);\n      }\n    });\n\n    test('should prevent client users from accessing coach features', async ({ page }) => {\n      // Login as client\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'client@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Try to access coach-only features\n      const coachRoutes = [\n        '/coach/dashboard',\n        '/coach/sessions',\n        '/coach/calendar',\n        '/coach/analytics',\n        '/coach/profile'\n      ];\n      \n      for (const route of coachRoutes) {\n        await page.goto(route);\n        \n        // Should be redirected or show access denied\n        const currentUrl = page.url();\n        expect(currentUrl).not.toBe(`${page.url().split('/').slice(0, 3).join('/')}${route}`);\n      }\n    });\n\n    test('should validate API request permissions', async ({ page }) => {\n      // Login as regular user\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'client@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Try to make unauthorized API calls\n      const unauthorizedCalls = [\n        { method: 'GET', url: '/api/admin/users' },\n        { method: 'POST', url: '/api/admin/coaches/approve' },\n        { method: 'DELETE', url: '/api/admin/users/123' },\n        { method: 'PUT', url: '/api/coaches/other-user-id/profile' }\n      ];\n      \n      for (const call of unauthorizedCalls) {\n        const response = await page.request.fetch(call.url, {\n          method: call.method,\n          data: call.method !== 'GET' ? {} : undefined\n        }).catch(() => null);\n        \n        if (response) {\n          // Should return 401 or 403\n          expect([401, 403]).toContain(response.status());\n        }\n      }\n    });\n  });\n\n  test.describe('Rate Limiting and Brute Force Protection', () => {\n    test('should implement rate limiting on login attempts', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const maxAttempts = 5;\n      \n      // Make multiple failed login attempts\n      for (let i = 0; i < maxAttempts + 2; i++) {\n        await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n        await page.fill('[data-testid=\"login-password\"]', 'wrong-password');\n        await page.click('[data-testid=\"login-submit\"]');\n        \n        // Wait for response\n        await page.waitForTimeout(500);\n        \n        if (i >= maxAttempts) {\n          // Should show rate limiting message\n          const errorMessage = await page.locator('[data-testid=\"error-message\"]').textContent();\n          expect(errorMessage).toMatch(/too many attempts|rate limit|try again later/i);\n          \n          // Login button should be disabled or show cooldown\n          const submitButton = page.locator('[data-testid=\"login-submit\"]');\n          const isDisabled = await submitButton.isDisabled();\n          expect(isDisabled).toBe(true);\n          \n          break;\n        }\n      }\n    });\n\n    test('should implement rate limiting on registration', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      // Attempt multiple rapid registrations\n      for (let i = 0; i < 6; i++) {\n        await page.fill('[data-testid=\"registration-email\"]', `spam${i}@example.com`);\n        await page.fill('[data-testid=\"registration-password\"]', 'ValidPassword123!');\n        await page.fill('[data-testid=\"registration-full-name\"]', 'Spam User');\n        await page.click('[data-testid=\"register-submit\"]');\n        \n        await page.waitForTimeout(100);\n        \n        if (i >= 3) {\n          // Should eventually show rate limiting\n          const errorMessage = await page.locator('[data-testid=\"error-message\"]').textContent();\n          if (errorMessage && errorMessage.match(/rate limit|too many|try again/i)) {\n            break;\n          }\n        }\n      }\n    });\n\n    test('should implement rate limiting on password reset', async ({ page }) => {\n      await page.goto('/auth/forgot-password');\n      \n      // Attempt multiple password reset requests\n      for (let i = 0; i < 4; i++) {\n        await page.fill('[data-testid=\"reset-email\"]', 'test@example.com');\n        await page.click('[data-testid=\"reset-submit\"]');\n        \n        await page.waitForTimeout(500);\n        \n        if (i >= 2) {\n          // Should show rate limiting after several attempts\n          const message = await page.locator('[data-testid=\"rate-limit-message\"]')\n            .textContent()\n            .catch(() => null);\n          \n          if (message && message.match(/rate limit|too many/i)) {\n            expect(message).toMatch(/rate limit|too many/i);\n            break;\n          }\n        }\n      }\n    });\n  });\n\n  test.describe('Secure Headers and Content Security', () => {\n    test('should include security headers', async ({ page }) => {\n      const response = await page.goto('/');\n      const headers = response?.headers() || {};\n      \n      // Check for important security headers\n      expect(headers['x-frame-options'] || headers['X-Frame-Options']).toBeDefined();\n      expect(headers['x-content-type-options'] || headers['X-Content-Type-Options']).toBe('nosniff');\n      \n      // CSP header should be present (implementation dependent)\n      if (headers['content-security-policy'] || headers['Content-Security-Policy']) {\n        const csp = headers['content-security-policy'] || headers['Content-Security-Policy'];\n        expect(csp).toContain('default-src');\n      }\n    });\n\n    test('should prevent content type sniffing', async ({ page }) => {\n      const response = await page.goto('/');\n      const contentType = response?.headers()['content-type'];\n      \n      expect(contentType).toMatch(/text\\/html/);\n      \n      // Should have X-Content-Type-Options: nosniff\n      const xContentType = response?.headers()['x-content-type-options'];\n      expect(xContentType).toBe('nosniff');\n    });\n  });\n\n  test.describe('Data Exposure Prevention', () => {\n    test('should not expose sensitive data in client-side storage', async ({ page }) => {\n      // Login to establish session\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForTimeout(1000);\n      \n      // Check localStorage and sessionStorage\n      const storage = await page.evaluate(() => {\n        return {\n          localStorage: { ...localStorage },\n          sessionStorage: { ...sessionStorage }\n        };\n      });\n      \n      const allStorage = { ...storage.localStorage, ...storage.sessionStorage };\n      \n      // Should not contain sensitive data\n      for (const [key, value] of Object.entries(allStorage)) {\n        const valueStr = String(value).toLowerCase();\n        \n        // Should not contain password\n        expect(valueStr).not.toMatch(/password/i);\n        \n        // Should not contain unencrypted tokens (basic check)\n        if (key.includes('token') || key.includes('auth')) {\n          // JWT tokens should be base64 encoded (contain dots)\n          if (valueStr.includes('.')) {\n            // This is likely a JWT, which is expected\n            continue;\n          }\n          // Other tokens should not be plain text\n          expect(valueStr).not.toMatch(/^[a-z0-9]{10,}$/);\n        }\n      }\n    });\n\n    test('should not expose user data in URL parameters', async ({ page }) => {\n      // Login and navigate through the app\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Navigate through various pages\n      const urlsToCheck = [\n        '/dashboard',\n        '/profile',\n        '/settings'\n      ];\n      \n      for (const url of urlsToCheck) {\n        await page.goto(url).catch(() => {});\n        const currentUrl = page.url();\n        \n        // URL should not contain sensitive data\n        expect(currentUrl.toLowerCase()).not.toMatch(/password|token|secret|key/i);\n        \n        // Should not contain email addresses in path\n        expect(currentUrl).not.toMatch(/@.*\\./); // Basic email pattern\n      }\n    });\n\n    test('should not expose internal errors to users', async ({ page }) => {\n      // Test various error scenarios\n      await page.goto('/auth/login');\n      \n      // Test with malformed requests\n      await page.evaluate(() => {\n        // Try to trigger an error\n        fetch('/api/auth/login', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: 'invalid json'\n        }).catch(() => {});\n      });\n      \n      // Check for error messages\n      const errorElements = await page.locator('[data-testid*=\"error\"]').all();\n      \n      for (const element of errorElements) {\n        const text = await element.textContent();\n        if (text) {\n          // Should not expose stack traces or internal paths\n          expect(text).not.toMatch(/stack|trace|internal|database|sql/i);\n          expect(text).not.toMatch(/\\/var\\/|C:\\\\|node_modules/i);\n        }\n      }\n    });\n  });\n\n  test.describe('CSRF Protection', () => {\n    test('should protect against CSRF attacks', async ({ page, context }) => {\n      // Login to establish session\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForTimeout(1000);\n      \n      // Get cookies\n      const cookies = await context.cookies();\n      \n      // Try to make a cross-origin request with stolen cookies\n      const response = await page.request.post('/api/user/profile', {\n        data: {\n          name: 'Hacked Name'\n        },\n        headers: {\n          'Origin': 'https://evil-site.com',\n          'Referer': 'https://evil-site.com/attack'\n        }\n      }).catch(() => null);\n      \n      if (response) {\n        // Should reject CSRF attempts\n        expect([400, 401, 403, 422]).toContain(response.status());\n      }\n    });\n  });\n});