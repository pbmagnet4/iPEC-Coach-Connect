/**
 * Authentication Performance Tests
 * 
 * Performance testing for authentication flows focusing on:
 * - Login/logout response times
 * - Session initialization performance
 * - State management efficiency
 * - Concurrent user handling
 * - Memory usage during auth operations
 * - Network request optimization
 * - Database query performance
 * - Large-scale user simulation
 */

import { test, expect, Page } from '@playwright/test';\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  LOGIN_TIME: 2000, // 2 seconds\n  LOGOUT_TIME: 1000, // 1 second\n  SESSION_INIT: 1500, // 1.5 seconds\n  STATE_UPDATE: 500, // 500ms\n  API_RESPONSE: 1000, // 1 second\n  MEMORY_LIMIT: 50 * 1024 * 1024, // 50MB\n  CONCURRENT_USERS: 10,\n};\n\n// Test utilities\nclass PerformanceHelpers {\n  static async measureExecutionTime<T>(operation: () => Promise<T>): Promise<{ result: T; time: number }> {\n    const startTime = Date.now();\n    const result = await operation();\n    const time = Date.now() - startTime;\n    return { result, time };\n  }\n\n  static async measurePageLoad(page: Page, url: string): Promise<number> {\n    const startTime = Date.now();\n    await page.goto(url);\n    await page.waitForLoadState('networkidle');\n    return Date.now() - startTime;\n  }\n\n  static async measureAuthStateChange(page: Page, operation: () => Promise<void>): Promise<number> {\n    let stateChangeTime = 0;\n    \n    // Listen for auth state changes\n    await page.addInitScript(() => {\n      (window as any).authStateChangeTime = 0;\n      \n      // Mock auth state listener if not available\n      if (typeof (window as any).authService !== 'undefined') {\n        const originalOnStateChange = (window as any).authService.onStateChange;\n        (window as any).authService.onStateChange = function(callback: any) {\n          const wrappedCallback = (state: any) => {\n            (window as any).authStateChangeTime = Date.now();\n            callback(state);\n          };\n          return originalOnStateChange.call(this, wrappedCallback);\n        };\n      }\n    });\n    \n    const startTime = Date.now();\n    await operation();\n    \n    // Wait for state change\n    await page.waitForFunction(() => {\n      return (window as any).authStateChangeTime > 0;\n    }, { timeout: 5000 }).catch(() => {});\n    \n    stateChangeTime = await page.evaluate(() => (window as any).authStateChangeTime);\n    \n    return stateChangeTime ? stateChangeTime - startTime : Date.now() - startTime;\n  }\n\n  static async getMemoryUsage(page: Page): Promise<number> {\n    return await page.evaluate(() => {\n      const memory = (performance as any).memory;\n      return memory ? memory.usedJSHeapSize : 0;\n    });\n  }\n\n  static async createTestUser(): Promise<{ email: string; password: string }> {\n    return {\n      email: `perf.test.${Date.now()}@example.com`,\n      password: 'PerformanceTest123!'\n    };\n  }\n}\n\ntest.describe('Authentication Performance Tests', () => {\n  test.describe('Login Performance', () => {\n    test('should complete login within performance threshold', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n        await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n        await page.fill('[data-testid=\"login-password\"]', 'password123');\n        await page.click('[data-testid=\"login-submit\"]');\n        \n        // Wait for successful login\n        await page.waitForURL('**/dashboard**', { timeout: 10000 }).catch(() => {});\n        await page.waitForSelector('[data-testid=\"user-menu\"]', { timeout: 5000 }).catch(() => {});\n      });\n      \n      console.log(`Login completed in ${time}ms`);\n      expect(time).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGIN_TIME);\n    });\n\n    test('should handle rapid login attempts efficiently', async ({ page }) => {\n      const loginTimes: number[] = [];\n      \n      for (let i = 0; i < 5; i++) {\n        await page.goto('/auth/login');\n        \n        const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n          await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n          await page.fill('[data-testid=\"login-password\"]', 'password123');\n          await page.click('[data-testid=\"login-submit\"]');\n          \n          await page.waitForTimeout(1000); // Wait for response\n        });\n        \n        loginTimes.push(time);\n        \n        // Logout for next iteration\n        if (await page.locator('[data-testid=\"user-menu\"]').isVisible({ timeout: 1000 })) {\n          await page.click('[data-testid=\"user-menu\"]');\n          await page.click('[data-testid=\"logout-button\"]');\n        }\n      }\n      \n      const averageTime = loginTimes.reduce((a, b) => a + b, 0) / loginTimes.length;\n      console.log(`Average login time: ${averageTime}ms`);\n      console.log(`Login times: ${loginTimes.join(', ')}ms`);\n      \n      // All attempts should be within threshold\n      loginTimes.forEach(time => {\n        expect(time).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGIN_TIME);\n      });\n      \n      // Performance should not degrade significantly\n      const maxTime = Math.max(...loginTimes);\n      const minTime = Math.min(...loginTimes);\n      const degradation = (maxTime - minTime) / minTime;\n      expect(degradation).toBeLessThan(2.0); // Max 200% degradation\n    });\n\n    test('should optimize network requests during login', async ({ page }) => {\n      const requests: any[] = [];\n      \n      page.on('request', request => {\n        requests.push({\n          url: request.url(),\n          method: request.method(),\n          timestamp: Date.now()\n        });\n      });\n      \n      await page.goto('/auth/login');\n      const startTime = Date.now();\n      \n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForTimeout(2000);\n      const endTime = Date.now();\n      \n      // Filter auth-related requests\n      const authRequests = requests.filter(req => \n        req.timestamp >= startTime && \n        req.timestamp <= endTime &&\n        (req.url.includes('/auth/') || req.url.includes('/api/'))\n      );\n      \n      console.log(`Auth requests: ${authRequests.length}`);\n      \n      // Should minimize the number of auth requests\n      expect(authRequests.length).toBeLessThan(5);\n      \n      // Should not have duplicate requests\n      const uniqueUrls = new Set(authRequests.map(req => req.url));\n      expect(uniqueUrls.size).toBe(authRequests.length);\n    });\n  });\n\n  test.describe('Session Management Performance', () => {\n    test('should initialize session state quickly', async ({ page }) => {\n      const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n        await page.goto('/');\n        \n        // Wait for auth state to be determined\n        await page.waitForFunction(() => {\n          return (window as any).authService && \n                 (window as any).authService.getState &&\n                 !(window as any).authService.getState().isLoading;\n        }, { timeout: 10000 }).catch(() => {});\n      });\n      \n      console.log(`Session initialization: ${time}ms`);\n      expect(time).toBeLessThan(PERFORMANCE_THRESHOLDS.SESSION_INIT);\n    });\n\n    test('should handle auth state changes efficiently', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const stateChangeTime = await PerformanceHelpers.measureAuthStateChange(page, async () => {\n        await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n        await page.fill('[data-testid=\"login-password\"]', 'password123');\n        await page.click('[data-testid=\"login-submit\"]');\n      });\n      \n      console.log(`Auth state change: ${stateChangeTime}ms`);\n      expect(stateChangeTime).toBeLessThan(PERFORMANCE_THRESHOLDS.STATE_UPDATE);\n    });\n\n    test('should maintain performance with large session data', async ({ page }) => {\n      // Simulate large profile data\n      await page.addInitScript(() => {\n        // Mock large user profile\n        const largeProfile = {\n          id: 'large-profile-user',\n          fullName: 'Performance Test User',\n          bio: 'Lorem ipsum '.repeat(1000), // Large bio\n          specializations: Array(100).fill('Coaching Specialty'),\n          sessions: Array(1000).fill({ id: 'session', date: new Date().toISOString() }),\n          reviews: Array(500).fill({ rating: 5, comment: 'Great coach!' })\n        };\n        \n        (window as any).largeProfileData = largeProfile;\n      });\n      \n      const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n        await page.goto('/auth/login');\n        await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n        await page.fill('[data-testid=\"login-password\"]', 'password123');\n        await page.click('[data-testid=\"login-submit\"]');\n        \n        await page.waitForTimeout(2000);\n      });\n      \n      console.log(`Login with large profile: ${time}ms`);\n      expect(time).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGIN_TIME * 1.5); // Allow 50% more time\n    });\n  });\n\n  test.describe('Logout Performance', () => {\n    test('should complete logout quickly', async ({ page }) => {\n      // Login first\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForSelector('[data-testid=\"user-menu\"]', { timeout: 5000 });\n      \n      // Measure logout time\n      const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n        await page.click('[data-testid=\"user-menu\"]');\n        await page.click('[data-testid=\"logout-button\"]');\n        \n        // Wait for logout to complete\n        await page.waitForURL('**/auth/login', { timeout: 5000 }).catch(() => {});\n        await page.waitForSelector('[data-testid=\"login-form\"]', { timeout: 3000 }).catch(() => {});\n      });\n      \n      console.log(`Logout completed in ${time}ms`);\n      expect(time).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGOUT_TIME);\n    });\n\n    test('should clear session data efficiently', async ({ page }) => {\n      // Login and accumulate some session data\n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForSelector('[data-testid=\"user-menu\"]', { timeout: 5000 });\n      \n      // Navigate to create some session state\n      await page.goto('/dashboard').catch(() => {});\n      await page.goto('/profile').catch(() => {});\n      \n      const memoryBefore = await PerformanceHelpers.getMemoryUsage(page);\n      \n      // Logout\n      const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n        await page.click('[data-testid=\"user-menu\"]');\n        await page.click('[data-testid=\"logout-button\"]');\n        await page.waitForTimeout(1000);\n      });\n      \n      const memoryAfter = await PerformanceHelpers.getMemoryUsage(page);\n      \n      console.log(`Logout time: ${time}ms`);\n      console.log(`Memory before: ${(memoryBefore / 1024 / 1024).toFixed(2)}MB`);\n      console.log(`Memory after: ${(memoryAfter / 1024 / 1024).toFixed(2)}MB`);\n      \n      // Should clear session efficiently\n      expect(time).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGOUT_TIME);\n      \n      // Memory usage should decrease or stay reasonable\n      expect(memoryAfter).toBeLessThan(PERFORMANCE_THRESHOLDS.MEMORY_LIMIT);\n    });\n  });\n\n  test.describe('Concurrent User Performance', () => {\n    test('should handle multiple concurrent logins', async ({ browser }) => {\n      const contexts: any[] = [];\n      const loginTimes: number[] = [];\n      \n      try {\n        // Create multiple browser contexts for concurrent users\n        for (let i = 0; i < PERFORMANCE_THRESHOLDS.CONCURRENT_USERS; i++) {\n          contexts.push(await browser.newContext());\n        }\n        \n        // Perform concurrent logins\n        const loginPromises = contexts.map(async (context, index) => {\n          const page = await context.newPage();\n          const user = await PerformanceHelpers.createTestUser();\n          \n          const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n            await page.goto('/auth/login');\n            await page.fill('[data-testid=\"login-email\"]', user.email);\n            await page.fill('[data-testid=\"login-password\"]', user.password);\n            await page.click('[data-testid=\"login-submit\"]');\n            \n            // Wait for response (may fail for some users)\n            await page.waitForTimeout(2000);\n          });\n          \n          return { time, index };\n        });\n        \n        const results = await Promise.all(loginPromises);\n        results.forEach(result => loginTimes.push(result.time));\n        \n        const averageTime = loginTimes.reduce((a, b) => a + b, 0) / loginTimes.length;\n        const maxTime = Math.max(...loginTimes);\n        \n        console.log(`Concurrent logins - Average: ${averageTime}ms, Max: ${maxTime}ms`);\n        \n        // Average time should be reasonable\n        expect(averageTime).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGIN_TIME * 2);\n        \n        // No single login should take too long\n        expect(maxTime).toBeLessThan(PERFORMANCE_THRESHOLDS.LOGIN_TIME * 3);\n        \n      } finally {\n        // Cleanup contexts\n        await Promise.all(contexts.map(context => context.close()));\n      }\n    });\n\n    test('should maintain session performance under load', async ({ browser }) => {\n      const contexts: any[] = [];\n      \n      try {\n        // Create multiple authenticated sessions\n        for (let i = 0; i < 5; i++) {\n          const context = await browser.newContext();\n          const page = await context.newPage();\n          \n          await page.goto('/auth/login');\n          await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n          await page.fill('[data-testid=\"login-password\"]', 'password123');\n          await page.click('[data-testid=\"login-submit\"]');\n          \n          contexts.push(context);\n        }\n        \n        // Perform concurrent session operations\n        const operationPromises = contexts.map(async (context, index) => {\n          const page = await context.newPage();\n          \n          const { time } = await PerformanceHelpers.measureExecutionTime(async () => {\n            await page.goto('/dashboard');\n            await page.goto('/profile');\n            await page.goto('/settings');\n          });\n          \n          return time;\n        });\n        \n        const operationTimes = await Promise.all(operationPromises);\n        const averageTime = operationTimes.reduce((a, b) => a + b, 0) / operationTimes.length;\n        \n        console.log(`Concurrent session operations - Average: ${averageTime}ms`);\n        \n        // Should maintain reasonable performance\n        expect(averageTime).toBeLessThan(5000); // 5 seconds for multiple page loads\n        \n      } finally {\n        await Promise.all(contexts.map(context => context.close()));\n      }\n    });\n  });\n\n  test.describe('Memory and Resource Usage', () => {\n    test('should not create memory leaks during auth operations', async ({ page }) => {\n      const memoryReadings: number[] = [];\n      \n      // Perform multiple auth cycles\n      for (let i = 0; i < 10; i++) {\n        await page.goto('/auth/login');\n        await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n        await page.fill('[data-testid=\"login-password\"]', 'password123');\n        await page.click('[data-testid=\"login-submit\"]');\n        \n        await page.waitForTimeout(1000);\n        \n        // Logout\n        if (await page.locator('[data-testid=\"user-menu\"]').isVisible({ timeout: 1000 })) {\n          await page.click('[data-testid=\"user-menu\"]');\n          await page.click('[data-testid=\"logout-button\"]');\n        }\n        \n        // Force garbage collection if available\n        await page.evaluate(() => {\n          if ((window as any).gc) {\n            (window as any).gc();\n          }\n        });\n        \n        const memory = await PerformanceHelpers.getMemoryUsage(page);\n        memoryReadings.push(memory);\n      }\n      \n      console.log('Memory readings (MB):', memoryReadings.map(m => (m / 1024 / 1024).toFixed(2)));\n      \n      // Memory should not grow unbounded\n      const firstReading = memoryReadings[0];\n      const lastReading = memoryReadings[memoryReadings.length - 1];\n      const memoryIncrease = (lastReading - firstReading) / firstReading;\n      \n      expect(memoryIncrease).toBeLessThan(2.0); // Max 200% increase\n      expect(lastReading).toBeLessThan(PERFORMANCE_THRESHOLDS.MEMORY_LIMIT);\n    });\n\n    test('should efficiently manage DOM elements', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const initialElementCount = await page.evaluate(() => {\n        return document.querySelectorAll('*').length;\n      });\n      \n      // Perform login/logout cycle\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForTimeout(1000);\n      \n      if (await page.locator('[data-testid=\"user-menu\"]').isVisible({ timeout: 1000 })) {\n        await page.click('[data-testid=\"user-menu\"]');\n        await page.click('[data-testid=\"logout-button\"]');\n      }\n      \n      await page.waitForTimeout(1000);\n      \n      const finalElementCount = await page.evaluate(() => {\n        return document.querySelectorAll('*').length;\n      });\n      \n      console.log(`DOM elements - Initial: ${initialElementCount}, Final: ${finalElementCount}`);\n      \n      // Should not create excessive DOM elements\n      const elementIncrease = (finalElementCount - initialElementCount) / initialElementCount;\n      expect(elementIncrease).toBeLessThan(0.5); // Max 50% increase\n    });\n  });\n\n  test.describe('API Performance', () => {\n    test('should optimize authentication API calls', async ({ page }) => {\n      const apiCalls: any[] = [];\n      \n      page.on('response', response => {\n        if (response.url().includes('/auth/') || response.url().includes('/api/')) {\n          apiCalls.push({\n            url: response.url(),\n            status: response.status(),\n            timing: response.timing()\n          });\n        }\n      });\n      \n      await page.goto('/auth/login');\n      await page.fill('[data-testid=\"login-email\"]', 'test@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'password123');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      await page.waitForTimeout(3000);\n      \n      console.log(`API calls made: ${apiCalls.length}`);\n      \n      // Check response times\n      apiCalls.forEach(call => {\n        console.log(`${call.url}: ${call.timing?.responseEnd || 'N/A'}ms`);\n        if (call.timing?.responseEnd) {\n          expect(call.timing.responseEnd).toBeLessThan(PERFORMANCE_THRESHOLDS.API_RESPONSE);\n        }\n      });\n      \n      // Should minimize API calls\n      expect(apiCalls.length).toBeLessThan(10);\n    });\n  });\n});