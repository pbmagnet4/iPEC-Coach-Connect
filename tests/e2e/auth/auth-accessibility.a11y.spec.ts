/**
 * Authentication Accessibility Tests
 * 
 * Comprehensive accessibility testing for authentication components
 * ensuring WCAG 2.1 AA compliance and inclusive design principles.
 * 
 * Test Coverage:
 * - Screen reader compatibility
 * - Keyboard navigation
 * - Color contrast validation
 * - Focus management
 * - ARIA attributes and labels
 * - Form accessibility
 * - Error message accessibility
 * - High contrast mode support
 * - Reduced motion preferences
 */

import { test, expect, Page } from '@playwright/test';\nimport AxeBuilder from '@axe-core/playwright';\n\n// Accessibility test utilities\nclass AccessibilityHelpers {\n  /**\n   * Run axe accessibility scan on page\n   */\n  static async runAxeScan(page: Page, options: any = {}) {\n    const accessibilityScanResults = await new AxeBuilder({ page })\n      .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])\n      .analyze();\n    \n    return accessibilityScanResults;\n  }\n\n  /**\n   * Check if element is focusable\n   */\n  static async isFocusable(page: Page, selector: string): Promise<boolean> {\n    return await page.evaluate((sel) => {\n      const element = document.querySelector(sel) as HTMLElement;\n      if (!element) return false;\n      \n      // Check if element can receive focus\n      const tabIndex = element.tabIndex;\n      const isContentEditable = element.contentEditable === 'true';\n      const isFormElement = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA', 'A'].includes(element.tagName);\n      \n      return tabIndex >= 0 || isContentEditable || isFormElement;\n    }, selector);\n  }\n\n  /**\n   * Check focus order by tabbing through elements\n   */\n  static async getFocusOrder(page: Page): Promise<string[]> {\n    const focusOrder: string[] = [];\n    \n    // Start from the beginning\n    await page.keyboard.press('Tab');\n    \n    for (let i = 0; i < 20; i++) { // Limit to prevent infinite loops\n      const focusedElement = await page.evaluate(() => {\n        const focused = document.activeElement;\n        if (!focused || focused === document.body) return null;\n        \n        // Get a unique identifier for the element\n        return focused.getAttribute('data-testid') || \n               focused.id || \n               focused.className || \n               focused.tagName.toLowerCase();\n      });\n      \n      if (focusedElement) {\n        focusOrder.push(focusedElement);\n      }\n      \n      await page.keyboard.press('Tab');\n      \n      // Break if we've cycled back to the first element\n      if (focusOrder.length > 1 && focusedElement === focusOrder[0]) {\n        break;\n      }\n    }\n    \n    return focusOrder;\n  }\n\n  /**\n   * Check color contrast ratio\n   */\n  static async checkColorContrast(page: Page, selector: string): Promise<number> {\n    return await page.evaluate((sel) => {\n      const element = document.querySelector(sel) as HTMLElement;\n      if (!element) return 0;\n      \n      const styles = window.getComputedStyle(element);\n      const backgroundColor = styles.backgroundColor;\n      const color = styles.color;\n      \n      // Simple contrast ratio calculation (simplified for testing)\n      // In production, use a proper contrast ratio library\n      return parseFloat(styles.opacity) || 1;\n    }, selector);\n  }\n\n  /**\n   * Simulate screen reader announcement\n   */\n  static async getAriaAnnouncements(page: Page): Promise<string[]> {\n    return await page.evaluate(() => {\n      const liveRegions = document.querySelectorAll('[aria-live], [role=\"alert\"], [role=\"status\"]');\n      return Array.from(liveRegions).map(el => el.textContent || '').filter(Boolean);\n    });\n  }\n\n  /**\n   * Check if element has proper ARIA attributes\n   */\n  static async validateAriaAttributes(page: Page, selector: string): Promise<{\n    hasLabel: boolean;\n    hasDescription: boolean;\n    hasRole: boolean;\n    isAccessible: boolean;\n  }> {\n    return await page.evaluate((sel) => {\n      const element = document.querySelector(sel) as HTMLElement;\n      if (!element) return { hasLabel: false, hasDescription: false, hasRole: false, isAccessible: false };\n      \n      const hasLabel = !!(element.getAttribute('aria-label') || \n                         element.getAttribute('aria-labelledby') ||\n                         (element as HTMLLabelElement).htmlFor ||\n                         element.querySelector('label'));\n      \n      const hasDescription = !!(element.getAttribute('aria-describedby') ||\n                               element.getAttribute('title'));\n      \n      const hasRole = !!element.getAttribute('role');\n      \n      const isAccessible = hasLabel && !element.hasAttribute('aria-hidden');\n      \n      return { hasLabel, hasDescription, hasRole, isAccessible };\n    }, selector);\n  }\n}\n\ntest.describe('Authentication Accessibility Tests', () => {\n  test.describe('Login Page Accessibility', () => {\n    test('should pass axe accessibility scan', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const accessibilityScanResults = await AccessibilityHelpers.runAxeScan(page);\n      \n      expect(accessibilityScanResults.violations).toEqual([]);\n    });\n\n    test('should have proper heading structure', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Check for main heading\n      const mainHeading = page.locator('h1');\n      await expect(mainHeading).toBeVisible();\n      \n      // Verify heading content is descriptive\n      const headingText = await mainHeading.textContent();\n      expect(headingText).toMatch(/sign in|login|log in/i);\n      \n      // Check heading hierarchy\n      const headings = await page.evaluate(() => {\n        const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\n        return Array.from(headingElements).map(h => ({\n          level: parseInt(h.tagName.slice(1)),\n          text: h.textContent?.trim()\n        }));\n      });\n      \n      // Should start with h1 and not skip levels\n      expect(headings[0]?.level).toBe(1);\n    });\n\n    test('should support keyboard navigation', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const focusOrder = await AccessibilityHelpers.getFocusOrder(page);\n      \n      console.log('Focus order:', focusOrder);\n      \n      // Should include all interactive elements\n      expect(focusOrder).toContain('login-email');\n      expect(focusOrder).toContain('login-password');\n      expect(focusOrder).toContain('login-submit');\n      \n      // Should be able to navigate to forgot password link\n      expect(focusOrder.some(item => item.includes('forgot') || item.includes('password'))).toBe(true);\n    });\n\n    test('should complete login flow using only keyboard', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Navigate to email field\n      await page.keyboard.press('Tab');\n      let focused = await page.evaluate(() => document.activeElement?.getAttribute('data-testid'));\n      \n      // Find email input\n      while (focused !== 'login-email' && focused) {\n        await page.keyboard.press('Tab');\n        focused = await page.evaluate(() => document.activeElement?.getAttribute('data-testid'));\n      }\n      \n      // Fill email\n      await page.keyboard.type('test@example.com');\n      \n      // Navigate to password field\n      await page.keyboard.press('Tab');\n      await page.keyboard.type('password123');\n      \n      // Navigate to submit button and activate\n      await page.keyboard.press('Tab');\n      await page.keyboard.press('Enter');\n      \n      // Should initiate login process\n      await page.waitForTimeout(1000);\n      \n      // Check if login was attempted (by looking for loading state or redirect)\n      const currentUrl = page.url();\n      expect(currentUrl).not.toBe('/auth/login');\n    });\n\n    test('should have accessible form labels and inputs', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Check email input accessibility\n      const emailAccessibility = await AccessibilityHelpers.validateAriaAttributes(page, '[data-testid=\"login-email\"]');\n      expect(emailAccessibility.hasLabel).toBe(true);\n      expect(emailAccessibility.isAccessible).toBe(true);\n      \n      // Check password input accessibility\n      const passwordAccessibility = await AccessibilityHelpers.validateAriaAttributes(page, '[data-testid=\"login-password\"]');\n      expect(passwordAccessibility.hasLabel).toBe(true);\n      expect(passwordAccessibility.isAccessible).toBe(true);\n      \n      // Check submit button accessibility\n      const submitAccessibility = await AccessibilityHelpers.validateAriaAttributes(page, '[data-testid=\"login-submit\"]');\n      expect(submitAccessibility.isAccessible).toBe(true);\n      \n      // Verify form has proper fieldset/legend if grouped\n      const hasFieldset = await page.locator('fieldset').count();\n      if (hasFieldset > 0) {\n        await expect(page.locator('fieldset legend')).toBeVisible();\n      }\n    });\n\n    test('should provide accessible error messages', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Attempt login with invalid credentials\n      await page.fill('[data-testid=\"login-email\"]', 'invalid@example.com');\n      await page.fill('[data-testid=\"login-password\"]', 'wrongpassword');\n      await page.click('[data-testid=\"login-submit\"]');\n      \n      // Wait for error message\n      await page.waitForSelector('[data-testid=\"error-message\"]', { timeout: 5000 });\n      \n      // Check error message accessibility\n      const errorMessage = page.locator('[data-testid=\"error-message\"]');\n      await expect(errorMessage).toBeVisible();\n      \n      // Should have appropriate ARIA attributes\n      const errorAccessibility = await AccessibilityHelpers.validateAriaAttributes(page, '[data-testid=\"error-message\"]');\n      \n      // Error should be announced to screen readers\n      const ariaLive = await errorMessage.getAttribute('aria-live');\n      const role = await errorMessage.getAttribute('role');\n      \n      expect(ariaLive === 'polite' || ariaLive === 'assertive' || role === 'alert').toBe(true);\n      \n      // Should be associated with form fields\n      const emailInput = page.locator('[data-testid=\"login-email\"]');\n      const describedBy = await emailInput.getAttribute('aria-describedby');\n      \n      if (describedBy) {\n        expect(describedBy).toContain('error');\n      }\n    });\n  });\n\n  test.describe('Registration Page Accessibility', () => {\n    test('should pass axe accessibility scan', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      const accessibilityScanResults = await AccessibilityHelpers.runAxeScan(page);\n      \n      expect(accessibilityScanResults.violations).toEqual([]);\n    });\n\n    test('should have accessible form controls', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      const formControls = [\n        '[data-testid=\"registration-email\"]',\n        '[data-testid=\"registration-password\"]',\n        '[data-testid=\"registration-full-name\"]',\n        '[data-testid=\"registration-phone\"]'\n      ];\n      \n      for (const control of formControls) {\n        const accessibility = await AccessibilityHelpers.validateAriaAttributes(page, control);\n        expect(accessibility.hasLabel).toBe(true);\n        expect(accessibility.isAccessible).toBe(true);\n      }\n    });\n\n    test('should provide accessible password strength indicator', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      await page.fill('[data-testid=\"registration-password\"]', 'weak');\n      \n      // Check for password strength indicator\n      const strengthIndicator = page.locator('[data-testid=\"password-strength\"]');\n      if (await strengthIndicator.isVisible()) {\n        // Should be accessible to screen readers\n        const ariaLabel = await strengthIndicator.getAttribute('aria-label');\n        const ariaLive = await strengthIndicator.getAttribute('aria-live');\n        \n        expect(ariaLabel || ariaLive).toBeTruthy();\n        \n        // Should indicate current strength level\n        const strengthText = await strengthIndicator.textContent();\n        expect(strengthText).toMatch(/weak|strong|medium|password strength/i);\n      }\n    });\n\n    test('should handle role selection accessibly', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      // Check role radio buttons or select\n      const clientRole = page.locator('[data-testid=\"role-client\"]');\n      const coachRole = page.locator('[data-testid=\"role-coach\"]');\n      \n      if (await clientRole.isVisible()) {\n        // Should be part of a radio group\n        const clientName = await clientRole.getAttribute('name');\n        const coachName = await coachRole.getAttribute('name');\n        expect(clientName).toBe(coachName);\n        \n        // Should have accessible labels\n        const clientAccessibility = await AccessibilityHelpers.validateAriaAttributes(page, '[data-testid=\"role-client\"]');\n        expect(clientAccessibility.hasLabel).toBe(true);\n      }\n    });\n  });\n\n  test.describe('Focus Management', () => {\n    test('should manage focus during navigation', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Navigate to registration\n      await page.click('a[href*=\"register\"]');\n      \n      // Focus should be on a logical element (heading or first input)\n      const focusedElement = await page.evaluate(() => {\n        const focused = document.activeElement;\n        return focused?.tagName.toLowerCase() + (focused?.getAttribute('data-testid') ? `[${focused.getAttribute('data-testid')}]` : '');\n      });\n      \n      console.log('Focused element after navigation:', focusedElement);\n      \n      // Should not be on body or undefined\n      expect(focusedElement).not.toBe('body');\n    });\n\n    test('should trap focus in modal dialogs', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // If there are any modal dialogs, test focus trapping\n      const modalTrigger = page.locator('[data-testid*=\"modal\"], [data-testid*=\"dialog\"]').first();\n      \n      if (await modalTrigger.isVisible()) {\n        await modalTrigger.click();\n        \n        // Test focus trapping by tabbing through elements\n        const focusOrder = await AccessibilityHelpers.getFocusOrder(page);\n        \n        // Focus should cycle within modal\n        expect(focusOrder.length).toBeGreaterThan(0);\n      }\n    });\n  });\n\n  test.describe('Screen Reader Support', () => {\n    test('should provide descriptive page titles', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      const title = await page.title();\n      expect(title).toMatch(/sign in|login|log in/i);\n      expect(title).toContain('iPEC');\n      \n      // Navigate to registration\n      await page.goto('/auth/register');\n      \n      const regTitle = await page.title();\n      expect(regTitle).toMatch(/sign up|register|create account/i);\n    });\n\n    test('should announce form validation errors', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      // Trigger validation errors\n      await page.fill('[data-testid=\"registration-email\"]', 'invalid-email');\n      await page.fill('[data-testid=\"registration-password\"]', '123');\n      \n      // Check for live region announcements\n      const announcements = await AccessibilityHelpers.getAriaAnnouncements(page);\n      console.log('ARIA announcements:', announcements);\n      \n      // Should announce validation errors\n      const hasValidationAnnouncement = announcements.some(announcement => \n        announcement.includes('invalid') || \n        announcement.includes('error') ||\n        announcement.includes('required')\n      );\n      \n      expect(hasValidationAnnouncement).toBe(true);\n    });\n\n    test('should have proper landmark regions', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Check for main landmark\n      const main = page.locator('main, [role=\"main\"]');\n      await expect(main).toBeVisible();\n      \n      // Check for form landmark\n      const form = page.locator('form');\n      await expect(form).toBeVisible();\n      \n      // Verify landmarks have accessible names\n      const mainLabel = await main.getAttribute('aria-label') || await main.getAttribute('aria-labelledby');\n      if (mainLabel) {\n        expect(mainLabel).toBeTruthy();\n      }\n    });\n  });\n\n  test.describe('Color and Contrast', () => {\n    test('should meet color contrast requirements', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Test contrast for key elements\n      const elementsToTest = [\n        '[data-testid=\"login-submit\"]',\n        '[data-testid=\"login-email\"]',\n        'h1',\n        'label'\n      ];\n      \n      for (const selector of elementsToTest) {\n        const element = page.locator(selector).first();\n        if (await element.isVisible()) {\n          // Use axe to check contrast\n          const result = await new AxeBuilder({ page })\n            .include(selector)\n            .withRules(['color-contrast'])\n            .analyze();\n          \n          expect(result.violations.filter(v => v.id === 'color-contrast')).toEqual([]);\n        }\n      }\n    });\n\n    test('should work without color alone', async ({ page }) => {\n      await page.goto('/auth/register');\n      \n      // Fill form with invalid data\n      await page.fill('[data-testid=\"registration-password\"]', 'weak');\n      \n      // Check password strength indicator\n      const strengthIndicator = page.locator('[data-testid=\"password-strength\"]');\n      if (await strengthIndicator.isVisible()) {\n        // Should have text or icons, not just color\n        const text = await strengthIndicator.textContent();\n        const hasIcon = await strengthIndicator.locator('svg, i, [class*=\"icon\"]').count() > 0;\n        \n        expect(text?.trim() || hasIcon).toBeTruthy();\n      }\n    });\n  });\n\n  test.describe('Responsive and Mobile Accessibility', () => {\n    test('should be accessible on mobile devices', async ({ page }) => {\n      // Set mobile viewport\n      await page.setViewportSize({ width: 375, height: 667 });\n      await page.goto('/auth/login');\n      \n      // Run accessibility scan on mobile\n      const accessibilityScanResults = await AccessibilityHelpers.runAxeScan(page);\n      expect(accessibilityScanResults.violations).toEqual([]);\n      \n      // Check touch target sizes\n      const buttons = page.locator('button, a, input[type=\"submit\"]');\n      const buttonCount = await buttons.count();\n      \n      for (let i = 0; i < buttonCount; i++) {\n        const button = buttons.nth(i);\n        if (await button.isVisible()) {\n          const boundingBox = await button.boundingBox();\n          if (boundingBox) {\n            // Touch targets should be at least 44px\n            expect(boundingBox.width).toBeGreaterThanOrEqual(44);\n            expect(boundingBox.height).toBeGreaterThanOrEqual(44);\n          }\n        }\n      }\n    });\n\n    test('should support zoom up to 200%', async ({ page }) => {\n      await page.goto('/auth/login');\n      \n      // Zoom to 200%\n      await page.evaluate(() => {\n        document.body.style.zoom = '2';\n      });\n      \n      // Content should remain accessible\n      const accessibilityScanResults = await AccessibilityHelpers.runAxeScan(page);\n      expect(accessibilityScanResults.violations.filter(v => \n        !v.id.includes('zoom') && !v.id.includes('scale')\n      )).toEqual([]);\n      \n      // Form should still be usable\n      await expect(page.locator('[data-testid=\"login-email\"]')).toBeVisible();\n      await expect(page.locator('[data-testid=\"login-password\"]')).toBeVisible();\n      await expect(page.locator('[data-testid=\"login-submit\"]')).toBeVisible();\n    });\n  });\n\n  test.describe('Reduced Motion Support', () => {\n    test('should respect prefers-reduced-motion', async ({ page }) => {\n      // Set reduced motion preference\n      await page.emulateMedia({ reducedMotion: 'reduce' });\n      await page.goto('/auth/login');\n      \n      // Check that animations are disabled or reduced\n      const hasReducedMotion = await page.evaluate(() => {\n        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n      });\n      \n      expect(hasReducedMotion).toBe(true);\n      \n      // Verify animations respect the preference\n      const animatedElements = await page.locator('[class*=\"animate\"], [class*=\"transition\"]').count();\n      \n      if (animatedElements > 0) {\n        // Check that CSS animations are disabled\n        const animationDuration = await page.evaluate(() => {\n          const elements = document.querySelectorAll('[class*=\"animate\"], [class*=\"transition\"]');\n          for (const element of elements) {\n            const styles = window.getComputedStyle(element);\n            if (styles.animationDuration !== '0s' && styles.animationDuration !== '') {\n              return styles.animationDuration;\n            }\n          }\n          return '0s';\n        });\n        \n        expect(animationDuration).toBe('0s');\n      }\n    });\n  });\n});